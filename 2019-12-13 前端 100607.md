[TOC]

***



## 前端

#### 1.C-字符串

sprintf_s（src, "***"）

strcat(src1,src2) 组合

#### 2.CString

left(int n)

mid(int i,int n)

right(int n)

#### 3.全局变量

1. class类型的全局变量禁止
   - class全局变量的初始化顺序可能导致构造出现问题[^ 1 ]。
   - 内建类型和由内建类型构成的没有构造函数的结构体可以使用。
   - 如果一定要使用class全局变量请使用singleton pattern（单例模式）
2. 多线程代码非常数变量(含STL容器)也被禁止，不可以用函数返回值初始化全局变量。
3. 静态成员变量视作全局变量，也不可以是class类型。

​	

#### 4.类

1. 构造函数：构造函数不宜做逻辑复杂的初始化[^2]。

2. 初始化类不能用zeromemory，数组和结构体可以[^3]。

3. 明确的构造函数（Explicit Constructors）：对单参数构造函数使用C++关键字explicit，防止赋值时隐式转换。

4. 默认构造函数：当一个类定义若干成员变量又没有其他构造函数，需要定义一个默认构造函数，否则编译器自动产生默认构造函数。

5. 拷贝构造函数：仅需要拷贝一个类对象时使用拷贝构造函数；不需要时使用DISALLO_COPY_ASSIGN。

   ``` c++
   //禁止使用拷贝构造函数和赋值操作的宏
   //应在类的private：中使用
   #define DISALLOW_COPY_AND_ASSIGN(TypeNam)\
   TypeName(const TypeName&);\
   void operator=(const TypeName&)
   
   class Foo{
    public:
       Foo(int f);
       ~Foo();
    private:
       DISALLOW_COPY_AND_ASSIGN(Foo);
   }
   ```

6. 结构体和类：仅只有数据使用结构体，其他一概使用class。

7. 存取控制：变量foo_及取值函数foo()、赋值函数set_foo()。

8. 声明次序：public:\protected:\private:;如果那一块没有直接忽略即可。

   1. typedefs 和 enums；
   2. 常量
   3. 构造函数
   4. 析构函数
   5. 成员函数，含静态成员函数
   6. 数据成员，含静态数据成员
   7. 宏DISALLOW_COPY_AND_ASSIGN放在最后。
   8. .cpp和声明顺序一致。

9. STL容器中的对象，应该只使用std::tr1::shared_ptr。

10. 不具名的命名空间：在.cpp文件中提倡使用不具名命名空间，以避免命名冲突：

    ```c++
    namespace{
        //命名空间的内容无需缩进
        enum{UNUSED,EOF,ERROR}; //经常使用的符号
        bool AtEof(){return pos_==EOF;} //使用本命名空间内的符号EOF
    }//namespace
    
    //TODO:使用命名空间中的内容
    ```

11. 具名的命名空间：使用方式如下

    ```c++
    //.h文件
    namespace mynamespace{
        class MyClass{
            public:
            ...
            void Foo();
        };
    }// namespace mynamespace
    //.cc文件
    namespace mynamespace{
        void MyClass::Foo(){
            ...
        }
    }//namespace mynamespace
    ```

    通常.cpp中会包含更多、更复杂的细节，包括对其他命名空间中类的引用等。

    ```c++
    #include "a.h"
    
    DEFINE_bool(someflag,false,"dummy flag");
    
    class C;//全局命名空间中的类C的前置声明
    namespace a{class A;}//命名空间a中的类a::A的前置声明
    namespace b{
        ...code for b...
    }//namespace b
    ```

    不要声明命名空间std下的任何内容，包括标准库类的前置声明，声明std下的实体会导致不明确的行为，如，不可移植。声明标准库下的实体，需要包含对应的头文件。

    ```c++
    //允许：.cpp文件
    //.h文件中，必须在函数、方法或类的内部使用
    using::foo::bar;
    //允许：.cpp文件
    //.h文件中，必须在函数、方法或类的内部使用
    namespace fbz=::foo::bar::barZ;//别名
    ```

12. 头文件中的前置声明

    ```c++
    // 头文件
    // 前置声明
    SSNamespace
    {
     	class A;
    }
    
    class B
    {
        public:
        SSNamespace::A;
    }
    ```

    

#### 5. 宏定义

1. 宏定义简化代码

   ```c++
   #define SWITCH(ar,i) if(ar[i] < ar[i+1]){\
   	int nTemp = ar[i];\
   	ar[i] = nNums[i+1];\
   	ar[i+1] = nTemp;}
   ```

2. 缺点:<b>无法单步调试、宏定义没有类型、命名空间对宏定义无效</b>

3. 编译时完全展开，如果有运算符号最好加上括号。

   ```c++
   #define WIDTH 80
   #define LENGTH WIDTH + 10
   
   int nArea = WIDTH * LENGTH;
   //等效于 int nArea = 80*80+10
   
   //正确用法
   #define WIDTH 80
   #define LENGTH (WIDTH+10)
   
   
   ```

   

#### 5.用法



1. 单例模式

   - 饿汉模式singleton

     适合多线程

   ```c++
   #include <iostream>
   
   using namespace std;
   
   class Singleton
   {
   	static Singleton intance;
   	Singleton()
   	{
   
   	}
   	Singleton(Singleton& that)
   	{
   
   	}
   	void operator = (Singleton& that)
   	{
   
   	}
   public:
   	static Singleton& getIntance(void)
   	{
   		return intance;
   	}
   };
   
   Singleton Singleton::intance;
   ```

   - 懒汉模式

      省内存，不适合多线程

   ```c++
   #include <iostream>
   
   using namespace std;
   
   class Singleton
   {
   	static Singleton* intance;
   	Singleton()
   	{
   
   	}
   	Singleton(Singleton& that)
   	{
   
   	}
   	void operator = (Singleton& that)
   	{
   
   	}
   public:
   	static Singleton& getIntance(void)
   	{
   		if(NULL == intance)
   		{
   			intance = new Singleton;
   		}
   		return *intance;
   	}
   	~ Singleton(void)
   	{
   		delete intance;
   	}
   };
   
   Singleton* Singleton::intance = NULL;
   ```

2. doxygen产生帮助文档

3. namespace fbz=::foo::bar::baz;

4. 禁止使用using指示符，以保证命名空间下所有名称可以正常使用。

   ```c++
   //禁止--污染命名空间
   using namespace foo;
   //允许：.cpp文件中
   //.h文件中，必须在函数方法或类的内部使用
   using ::foo::bar;
   ```

5. #define DEFINE_T_SUPER(B) private: typedef B T_Super; public:

6. 宏例子

   ```c++
   #define DETAILEDMODEL_EXTENSION(_name_)\
   class _name_##Extension : public PBBimCore::IPBObjectExtension\
   {\
   protected:\
       virtual PBBimCore::IPBObjectPtr        _GetPBObject() override\
                                                                                                   						        {\
       return _name_::Create();\
                                                                                                   						        } \
       virtual PBBimCore::IPBObjectPtr        _GetPBObject(BentleyApi::ECN::IECInstanceCR instance) override\
                                                                                                   						        {\
       return _name_::Create(instance);\
                                                                                                   						        }\
   };//IPBObjectExtension
   ```

7. 线程锁

   ```c++
   HANDLE mutex
   class ScopedMutex{
       public:
       ScopedMutex(HANDLE mutex){mutex.lock();}
       ~ScopedMutex(HANDLE mutex){mutex.unlock();}
   }
   ```

8. 全局作用域符::

   ```c++
   ::print(); // 使用标准函数
   print(); //使用成员函数
   ```

9.  智能指针和stl容器

   ```c++
   #define SPMAP(A,B) std::map<A,std::shared_ptr<B>>
   #define SPCMAP(A,B) CMap<A,A,std::shared_ptr<B>,std::shared_ptr<B>>
   #define SPVECTOR(A) std::vector<std::shared_ptr<A>>
   #define SP(A) std::shared_ptr<A>
   #define SPCreate(A) std::make_shared<A>()
   
   //定义容器
   SPMAP(int,className) classMap;
   //添加变量
   SP(className) classObject;
   classMap[id] = classObject;
   //查找变量
   SP(className) classObject2;
   classObject2 = classMap.at(id);
   // *classObject2 就是智能指针指向的对象。
   ```
   
   [^1]:<font size = 2 >因为，全局变量的构造函数、析构函数以及初始化操作的调用顺序只是部分规定，每次生成有可能有变化，从而导致难以发现的bug。</font>
   [^2]: 如果对象需要有意义的初始化，考虑使用另外的Init()方法，并（或）增加一个成员标记用于指示对象是否已经初始化成功。
   [^3]: 如果结构体中有虚函数或结构体成员中有虚函数，则会将虚函数指针置0，如果后续程序调用虚函数，空指针很可能导致程序崩溃。因此，有虚函数或成员函数中有虚函数的结构体初始化，一定要用构造函数来完成。另外，如果一个类的结构中包含STL模板，使用ZeroMemory对这个对象清零操作也会引起一系列的崩溃问题（指针指向内存错误、迭代器越界访问等）。
   
   #### 6.字符串

1. unicode下各种字符串的转换

   ```c++
   1. Cstring std::string互转
   std::string strstring = "std::string";
   CString strCString = _T("CString");
   //CString->std::string
   strstring = CStringA(strCString);
   
   //std::string->CString
   strCString = strstring.c_str();
   
   2. int和CString
   //CString->int
   CString strInt = _T("123");
   int n=0;
   n = _ttoi(strInt);
   n = 9;
   //int->CString
   strInt.Format(_T(%d),n);
   
   3、double和CString
   CString strdouble = _T("123.00");
   double dVal = 0;
   //CString->double
   dVal = _tstof(strdouble);
   dVal = 999.0;
   //double->CString
   strdouble.Format(_T("%f"), dVal);
   
   4、char*和CString
   char* chchar = "chahdaslhdf";
   CString strCh = _T("char");
   //char*->CString
   strCh = chchar;
   //或者
   //预转换，得到所需空间的大小
   int wcsLen = ::MultiByteToWideChar(CP_ACP, NULL, chchar, strlen(chchar), NULL, 0);
   //分配空间要给'\0'留个空间，MultiByteToWideChar不会给'\0'空间
   wchar_t* wszString = new wchar_t[wcsLen + 1];
   //转换
   ::MultiByteToWideChar(CP_ACP, NULL, chchar, strlen(chchar), wszString, wcsLen);
   //最后加上'\0'
   wszString[wcsLen] = '\0';
   //附加到CString对象上
   CString content;
   content.Append(wszString);
   
   //CString->char*
   int n = strCh.GetLength(); //按字符计算，strCh的长度
   
   int len = WideCharToMultiByte(CP_ACP, 0, strCh, n, NULL, 0, NULL, NULL);//按Byte计算str长度
   char *pChStr = new char[len+1];//按字节为单位
   memset(pChStr,0,len+1);
   WideCharToMultiByte(CP_ACP, 0, strCh, n, pChStr, len, NULL, NULL);//宽字节转换为多字节编码
   pChStr[len] = '\0';
   memcpy(chDis, pChStr, len + 1);
   delete []pChStr;
   
   CString转char*
   //有问题，测试不通过，jxq
   char* ch = new char;
   CString str1 = _T("12121");
   strcpy(ch, CStringA(str1).GetString());
   
   5、将wchar_t*转化为char*
   
   char* UnicodeToAnsi(const wchar_t* szStr) 
   { 
       int nLen = WideCharToMultiByte( CP_ACP, 0, szStr, -1, NULL, 0, NULL, NULL ); 
       if (nLen == 0) 
       return NULL;
   
       char* pResult = new char[nLen+1]; 
       WideCharToMultiByte( CP_ACP, 0, szStr, -1, pResult, nLen, NULL, NULL );
       return pResult; 
   }
   
   6、将char*转化为wchar_t*
   
   wchar_t* AnsiToUnicode(const char* szStr) 
   { 
       int nLen = MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, szStr, -1, NULL, 0 ); 
       if (nLen == 0) 
       return NULL;
   
       wchar_t* pResult = new wchar_t[nLen+1]; 
       MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, szStr, -1, pResult, nLen ); 
       return pResult; 
   }
   
    
   
   7、头文件#include <sstream>
   //int->string
   int n1 = 0;
   std::stringstream ssCov;
   std::string str;
   ssCov<<n1;
   ssCov>>str;
   
   
   //string->int
   std::string strNum = "123";
   int n2 = atoi(strNum.c_str());
   
   //tchar 转 char
   std::string TCHAR2STRING（TCHAR *STR）
   
   {
   
    int iLen = WideCharToMultiByte(CP_ACP, 0,STR, -1, NULL, 0, NULL, NULL);
   
    char* chRtn =new char[iLen*sizeof(char)];
   
    WideCharToMultiByte(CP_ACP, 0, STR, -1, chRtn, iLen, NULL, NULL);
   
   std::string str(chRtn);
   
   return str;
   
   }
   ```

2. 多字节下各种字符串的转换

   ```c++
   //Cstring->char*
   char* buf;
   CString str="hello";
   buf=(LPSTR)(LPCTSTR)str;
   ```

3. utf-8相关

   ```c++
   using std::wstring;
   //UTF-8转Unicode 
   std::wstring CComTools::Utf82Unicode(const std::string& utf8string)
   {
   	int widesize = ::MultiByteToWideChar(CP_UTF8, 0, utf8string.c_str(), -1, NULL, 0);
   	if (widesize == ERROR_NO_UNICODE_TRANSLATION)
   	{
   		throw std::exception("Invalid UTF-8 sequence.");
   	}
   	if (widesize == 0)
   	{
   		throw std::exception("Error in conversion.");
   	}
   	std::vector<wchar_t> resultstring(widesize);
   	int convresult = ::MultiByteToWideChar(CP_UTF8, 0, utf8string.c_str(), -1, &resultstring[0], widesize);
   	if (convresult != widesize)
   	{
   		throw std::exception("La falla!");
   	}
   	return std::wstring(&resultstring[0]);
   }
   //unicode 转为 ascii 
   string CComTools::WideByte2Acsi(wstring& wstrcode)
   {
   	int asciisize = ::WideCharToMultiByte(CP_OEMCP, 0, wstrcode.c_str(), -1, NULL, 0, NULL, NULL);
   	if (asciisize == ERROR_NO_UNICODE_TRANSLATION)
   	{
   		throw std::exception("Invalid UTF-8 sequence.");
   	}
   	if (asciisize == 0)
   	{
   		throw std::exception("Error in conversion.");
   	}
   	std::vector<char> resultstring(asciisize);
   	int convresult = ::WideCharToMultiByte(CP_OEMCP, 0, wstrcode.c_str(), -1, &resultstring[0], asciisize, NULL, NULL);
   	if (convresult != asciisize)
   	{
   		throw std::exception("La falla!");
   	}
   	return std::string(&resultstring[0]);
   }
   //utf-8 转 ascii 
   string CComTools::UTF_82ASCII(string& strUtf8Code)
   {
   	string strRet("");
   	//先把 utf8 转为 unicode 
   	wstring wstr = Utf82Unicode(strUtf8Code);
   	//最后把 unicode 转为 ascii 
   	strRet = WideByte2Acsi(wstr);
   	return strRet;
   }
   /// 
   //ascii 转 Unicode 
   wstring CComTools::Acsi2WideByte(string& strascii)
   {
   	int widesize = MultiByteToWideChar(CP_ACP, 0, (char*)strascii.c_str(), -1, NULL, 0);
   	if (widesize == ERROR_NO_UNICODE_TRANSLATION)
   	{
   		throw std::exception("Invalid UTF-8 sequence.");
   	}
   	if (widesize == 0)
   	{
   		throw std::exception("Error in conversion.");
   	}
   	std::vector<wchar_t> resultstring(widesize);
   	int convresult = MultiByteToWideChar(CP_ACP, 0, (char*)strascii.c_str(), -1, &resultstring[0], widesize);
   	if (convresult != widesize)
   	{
   		throw std::exception("La falla!");
   	}
   	return std::wstring(&resultstring[0]);
   }
   //Unicode 转 Utf8 
   std::string CComTools::Unicode2Utf8(const std::wstring& widestring)
   {
   	int utf8size = ::WideCharToMultiByte(CP_UTF8, 0, widestring.c_str(), -1, NULL, 0, NULL, NULL);
   	if (utf8size == 0)
   	{
   		throw std::exception("Error in conversion.");
   	}
   	std::vector<char> resultstring(utf8size);
   	int convresult = ::WideCharToMultiByte(CP_UTF8, 0, widestring.c_str(), -1, &resultstring[0], utf8size, NULL, NULL);
   	if (convresult != utf8size)
   	{
   		throw std::exception("La falla!");
   	}
   	return std::string(&resultstring[0]);
   }
   //ascii 转 Utf8 
   string CComTools::ASCII2UTF_8(string& strAsciiCode)
   {
   	string strRet("");
   	//先把 ascii 转为 unicode 
   	wstring wstr = Acsi2WideByte(strAsciiCode);
   	//最后把 unicode 转为 utf8 
   	strRet = Unicode2Utf8(wstr);
   	return strRet;
   }
   ```
```c++

```

   



#### 7.mfc

1. messagebox对话框在程序后面加MB_SYSTEMMODAL
   ```c++
   ::MessageBox(Null,info,)
       
   ```

2. COM的基础是这些概念。

   interface----对象通过它来展示其功能的机制。

   IUnknown----所有其他的基本接口都是基于它。它实现了通过COM运行的引用计数和接口查询机制。

   reference  counting----一个对象（或严格来说，一个接口）决定何时不再使用，因此可以自由地删除自己的技术。

   QueryInterface - 用于查询对象对给定接口的方法。

   Marshaling - 使对象可以跨线程、进程和网络边界使用的机制，允许位置独立。

   Aggregation - 一个对象可以利用另一个对象的一种方式。
   
3. 创建console并输出

   ```c++
   #include <fcntl.h>
   #include <io.h>
   
          
   
   void CallConcoleOutput(void)
   {
     int hCrt;
     FILE *hf;
     AllocConsole();
     hCrt=_open_osfhandle(
     (long)GetStdHandle(STD_OUTPUT_HANDLE),
     _O_TEXT );
     hf=_fdopen( hCrt, "w" );
     *stdout=*hf;
     setvbuf( stdout, NULL, _IONBF, 0 );
     // test code
     printf("InitConsoleWindow OK!/n");
   }
   ```

4. CreateProcess 调用子程序的对话框

   ```c++
   STARTUPINFO sui;
   	PROCESS_INFORMATION pi;
   	ZeroMemory(&sui, sizeof(STARTUPINFO));
   	sui.cb = sizeof(STARTUPINFO);
   	sui.dwFlags = STARTF_USESHOWWINDOW;
   	// 如果需要重定向，sui.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
   	sui.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
   	sui.hStdOutput = GetStdHandle(STD_OUTPUT_HANDLE);
   	sui.hStdError = GetStdHandle(STD_ERROR_HANDLE);
   	sui.wShowWindow = SW_SHOW;
   	// 如果需要重定向 sui.wShowWindow = SW_HIDE;
   	TCHAR exename[256] = _T("pserver.exe");
   	if (!CreateProcess(NULL, exename, NULL, NULL, TRUE, CREATE_NEW_CONSOLE, NULL, NULL, &sui, &pi))
   ```

   

5. SendMessage 能以同步方式向目标窗体发送一条消息，然后等待目标窗体的处理过程处理。

   PostMessage 能以异步方式向目标窗体投递一条消息，消息投递出去函数立刻返回。

#### 8.调试经验

1. C/C++ 内存操作越界:sob:
    [<font size=1>转载链接</font>](<http://blog.sina.com.cn/s/blog_6b511ea50102visk.html>)

  - <font size=2>特点：莫名其妙出现众多问题，经常调来调去，不知原因所在，大部分都是内存操作引起的。现总结为两类：一类是无明显表现的，只会个程序带来莫名其妙的错误（1，2，3），一类调试时有明显表现（4，5）</font>

    1. <font size=2>字符串数组定义长度忘记+1（结束符）</font>

      ```c++
      char str[10];
      ::strcpy(str,"0123456789");
      ```

      <font size=2>此时会造成数组越界，因为strcpy将在str为起始地址的第11个单元写入‘0’，这样它将覆盖这个单元的值。</font>
    
      <font size=2>但是如果你仅仅作字符串操作，一个一个的存入，此时将不会越界，或者你使用strncpy(str,"0123456789",10)，它也不会越界。不过你得小心，此时将不能使用如：strlen，strcpy等等。它的长度和内容变得完全不确定，如果从str地址起的单元都不为‘’，那么将全看作为它的内容，此时对它的操作将会是多么的恐怖！</font>
    
    2. <font size=2>以指针操作数组</font>
    
       <font size=2>指针相对数组的下标操作来说，更灵活、更高效，但常常一不小心它就跑到不知地方的地方去了，在循环批量处理中，多移一位就产生了越界，如果是读还好，但如果是写，这就跟上面出现的问题一样了。</font>
    
    3. <font size=2>将对数据类型的错误操作</font>
    
       ```c++
       short int x;
       int y;
       x=y;
       //这种操作是不会出错，编译器会解释为x=(short int)y;丢弃y的高位。
       void *p;
       p=&x;
       *(int*)p=y;
       //这种操作会有问题。
       ```

       <font size=2>x只有两个字节的空间，而int需要4个字节的空间, 实际上己出问题了，但你放心，现在的编译器编译后不会引起错误，因为由于内存对齐操作，实际上它分配了4个字节给x，你没有写入到其它数中去，运行会完全正常。</font>
    
       <font color=orange size=2>但当你定义的是数组时，那就会有影响了，它会覆盖你后面的数据。
       或者你在不同的编程语言中进行数据交换时，而类型与类型宽度不一致就会出问题，如VB中的Integer只有2个字节，而VC中的int是4个，当接口定义不够好时，那就会引发程序崩溃。</font>
    
    4. <font size=2>使用new分配空间，但操作越界</font>:heart_decoration:
    
       <font size=2>这类越界要容易发现一点，只要你以debug版运行，只要你越界，程序肯定会在delete处停下来。第一次出现此类问题时，真是迷惑不解，我的指针怎么都没变，但就是delete不掉，老报错。由于不知越界会造成此类问题，我一直以为我的电脑哪出毛病了，很正确的事，它就是不对，简直气得我吐血，后来得人指点，才明白，原来这里面还有这个东东！同理malloc，free有此问题。</font>
    
    5. <font size=2>CString在GetBuffer后也容易出现越界</font>
    
       <font size=2>CString确实有很多好用的地方，我最爱它的地方就是作参数，它可以让被调用的函数内分配空间，而在函数外无需对得来的空间进行释放。在CString析构时，它就会帮你释放这块空间。</font>
       <font size=2>但在这里面有一个函数你使用不当就会出现越界问题，那就是CString::GetBuffer。通过操作它返回的指针，你便可以直接操作它的缓冲区，这相对通过它的方法来操作内容效率要高出很多，但若你一不小心越界了，那错误也就出来了。不过还好在调试版中，ReleaseBuffer时会报错，若你没有调用ReleaseBuffer，那将在CString析构时报错。</font>
    
    6. <font size=2>函数返回指针</font>
    
       <font size=2>这种要尤其小心，返回的指针指向的内存要释放，而且不要直接使用该指针操作，例如</font>
    
       ```c++
       char *buffer;
       if((buffer=getcwd(NULL,0))==NULL){
           perror("_getcwderror");
       }else{
           printf("%s\nLength:%d\n",buffer,strlen(buffer));
           free(buffer);//如果不free，后面的代码运行就会有问题。
       }
       ```

       <font size=2>上面4、5、6在调试会报错，因为在释放内存时，都调用delete，而delete实现如下</font>
    
       ``` c++
       void __cdecl operator delete(void* p)
       {
       #if !defined(_AFX_NO_DEBUG_CRT) && defined(_DEBUG)
       _free_dbg(p, _NORMAL_BLOCK);
       #else
       free(p);
       #endif
       }
       ```

       <font size=2>_free_dbg(p, _NORMAL_BLOCK);　将会作很多方面的检查，如果出错，便会报告出来。而free(p);则只是简间的对内存释放</font>
    
    7. <font size=2>总结</font>
    
       <font size=2>通过上面几点，相信大家知道如何去避免一些内存越界问题，同时也了解内存越界会引发各类问题，在我们遇到一些希奇古怪的问题时，不防关心一下你的内存操作。</font>
       
    8. 一个简单的创建被调试进程的案例
    
       ```c++
       //1. 创建被调试进程之后，被调试进程的进程线程的句柄与ID如何获取(PROCESS_INFORMATION)。
       
       //2. DEBUG_EVENT 的数据结构，u是对应的事件种类的数据结构。
       
       //3. 等待被调试进程的大体流程：使用 WaitForDebugEvent，等待被调试事件；使用ContinueDebugEvent，继续执行被调试事件。
       
       //4. 加载DLL时如果输出DLL名字：这里有个坑，必须连续两次从目标进程中读取，第一次读取地址，第二次通过该地址获取DllName，即文件名
           
       #include "pch.h"
       #include <iostream>
       #include <Windows.h>
       #include <string>
       
       using namespace std;
       
       int main()
       {
           CHAR DllName[MAX_PATH] = {'\0'}; // 存储DLL的缓冲区
           SIZE_T nNumberOfBytesRead = 0;    // 读取的字节数
           DWORD dwAddrImageName = 0;
           STARTUPINFO si = { sizeof(si) };
           PROCESS_INFORMATION pi;
           string path;
       
           LPCSTR x = "C:\\Users\\97905\\Desktop\\记事本.exe";
           if (CreateProcessA(
               x, // 进程名字  
               NULL, // 命令行为空
               NULL, // 进程安全描述符
               NULL, // 线程安全描述符
               FALSE, // 不可继承
               DEBUG_ONLY_THIS_PROCESS | DEBUG_PROCESS, // 调试模式启动
               NULL, // 使用父进程的环境块
               NULL, // 与父进程有相同的目录
               (LPSTARTUPINFOA)&si, // 必须初始化
               &pi // 被创建进程的句柄，线程等有关信息
           )) {
               cout << "创建被调试进程成功！" << endl;
           }
           else {
               cout << "创建被调试进程失败，退出" << endl;
               exit(0);
           }
       
           // 等待调试事件
           DEBUG_EVENT de; // 申请调试事件
           // 循环读取调试事件
           while (WaitForDebugEvent(&de, INFINITE) != 0) {
               if (pi.dwProcessId == de.dwProcessId) {
                   switch (de.dwDebugEventCode) {
                   case EXCEPTION_DEBUG_EVENT: // 异常事件
                       cout << "EXCEPTION_DEBUG_EVENT：" << endl;
                       //ContinueDebugEvent(de.dwProcessId, de.dwThreadId
                       break;
                   case CREATE_THREAD_DEBUG_EVENT: // 线程创建事件
                       cout << "CREATE_THREAD_DEBUG_EVENT" << endl;
                       break;
                   case CREATE_PROCESS_DEBUG_EVENT: // 进程创建事件
                       cout << "EXCEPTION_DEBUG_EVENT" << endl;
                       break;
                   case EXIT_THREAD_DEBUG_EVENT: // 线程退出事件
                       cout << "EXIT_THREAD_DEBUG_EVENT" << endl;
                       break;
                   case EXIT_PROCESS_DEBUG_EVENT: // 进程退出事件
                       cout << "EXIT_PROCESS_DEBUG_EVENT" << endl;
                       break;
                   case LOAD_DLL_DEBUG_EVENT: // DLL加载事件
                       ReadProcessMemory(pi.hProcess, de.u.LoadDll.lpImageName, &dwAddrImageName, sizeof(dwAddrImageName), &nNumberOfBytesRead);
                       ReadProcessMemory(pi.hProcess, (void*)dwAddrImageName, DllName, sizeof(DllName), &nNumberOfBytesRead);
                       if (de.u.LoadDll.fUnicode) {
                           wprintf(L"DLLNAME: %s\n", DllName);
                       }
                       else {
                           printf("DLLNAME: %s\n", DllName);
                       }
                       break;
                   case UNLOAD_DLL_DEBUG_EVENT: // 卸载DLL事件
                       cout << "UNLOAD_DLL_DEBUG_EVENT" << endl;
                       break;
                   case OUTPUT_DEBUG_STRING_EVENT: // 输出DEBUG字符串事件
                       cout << "OUTPUT_DEBUG_STRING_EVENT: " << de.u.DebugString.fUnicode << endl;
                       break;
                   }
                   ContinueDebugEvent(de.dwProcessId, de.dwThreadId, DBG_CONTINUE);
               }
           }
       }
          
       ```

    9. CreateProcess可以在32位程序中调用64位程序。:anger: 神奇！

#### 9.lambda表达式

1. 

   ```c++
    1      2     3       4       5      7
   [=] (int a) mutable throw() -> int （4）
    {
        6
    }
   1. =值传递； &引用传递 
       [&total,factor]
       [&,factor]
       [=,&total]
       lambda表达式的“参数”是在被调用时拷贝，而“被捕获的变量的值”是在lambda表达式创建时拷贝
       按值捕获，则在lambda创建时值被捕获，后续修改再影响。
       按引用捕获，则在lambda创建后到被调用前，捕获变量的改变都会被计算。
   2. () 形参表
   3.  mutable 可以使在按值传递时能够改变传入的值
   4.  throw（）表明不抛出异常。此时如果函数体throw异常，会有警报C4297
   5. 返回值
   6. 函数体
   7. 传入实参
       
   //e.g. 值捕获和引用捕获
   
   int _tmain(int argc, _TCHAR* argv[])
   {
   	using namespace std;
   	string strTemp = "非静态局部变量";
   	int iTemp = 10;
   	
   	//定义lambda
   	auto fun = [strTemp, &iTemp]()
   	{	
   		cout << strTemp << endl;
   		cout << iTemp << endl;
   	};
    
   	//改变两个局部变量的值
   	strTemp = "local";
   	iTemp = 20;
    
   	fun();//执行lambda
    
   	system("pause");
   	return 0;
   }
   //————————————————输出结果
   //非静态局部变量
   //20
   //非静态局部变量是值捕获，捕获的是lambda定义时的初值。
   // iTemp是引用捕获，捕获的是调用时候的值。
   
   //原文链接：https://blog.csdn.net/yedawei_1/article/details/109508875
   ```


#### 10.Fortran调用

1. extern'C' 按照c语言方式在函数名前加下划线 ‘_’

2. __stdcall会在函数名后面加上@字节数

   ```c++
   //_ShowOpenPDBDlg@4
   extern "C" __declspec(dllexport) void __stdcall ShowOpenPDBDlg(int &status)
   //其中extern“C” 提供下划线 	__stdcall提供@和字节数
   ```

3. 关于fortran接口

   ```fortran
   SUBROUTINE DATA_Prepare(status)
   !Dec$ Attributes STDCALL,DLLIMPORT,  Decorate, Alias : 'ShowOpenPDBDlg' :: DATA_Prepare
   integer(kind=4) :: status
   !Dec$ Attributes REFERENCE:: status
   END SUBROUTINE
   其中 STDCALL和Decorate会提供@4
   DLLIMPORT会在函数前加上_imp
   所以符号就是__imp__ShowOpenPDBDlg@4
   ```

4. 名字修饰约定随调用约定和编译种类(C或C++)的不同而变化。函数名修饰约定随编译种类和调用约定

   　　的不同而不同，下面分别说明。

      　　a、C编译时函数名修饰约定规则：

      　　__stdcall调用约定在输出函数名前加上一个下划线前缀，后面加上一个“@”符号和其参数的字节数，

      　　格式为_functionname@number。

      　　__cdecl调用约定仅在输出函数名前加上一个下划线前缀，格式为_functionname。

      　　__fastcall调用约定在输出函数名前加上一个“@”符号，后面也是一个“@”符号和其参数的字节数，

      　　格式为@functionname@number。

      　　它们均不改变输出函数名中的字符大小写，这和PASCAL调用约定不同，PASCAL约定输出的函数名无任何修饰且全部大写。

      　　b、C++编译时函数名修饰约定规则：

      　　__stdcall调用约定：

      　　1、以“?”标识函数名的开始，后跟函数名；

      　　2、函数名后面以“@@YG”标识参数表的开始，后跟参数表；

      　　3、参数表以代号表示：

      　　X--void ，

      　　D--char，

      　　E--unsigned char，

      　　F--short，

      　　H--int，

      　　I--unsigned int，

      　　J--long，

      　　K--unsigned long，

      　　M--float，

      　　N--double，

      　　_N--bool，

      　　....

      　　PA--表示指针，后面的代号表明指针类型，如果相同类型的指针连续出现，以“0”代替，一个“0”代

      　　表一次重复；

      　　4、参数表的第一项为该函数的返回值类型，其后依次为参数的数据类型,指针标识在其所指数据类型前

      　　；

      　　5、参数表后以“@Z”标识整个名字的结束，如果该函数无参数，则以“Z”标识结束。

      　　其格式为“?functionname@@YG*****@Z”或“?functionname@@YG*XZ”，例如

      　　int Test1（char *var1,unsigned long）-----“?Test1@@YGHPADK@Z”

      　　void Test2（） -----“?Test2@@YGXXZ”

      　　__cdecl调用约定：

      　　规则同上面的_stdcall调用约定，只是参数表的开始标识由上面的“@@YG”变为“@@YA”。

      　　__fastcall调用约定：

      　　规则同上面的_stdcall调用约定，只是参数表的开始标识由上面的“@@YG”变为“@@YI”。

      　　VC++对函数的省缺声明是"__cedcl",将只能被C/C++调用.

      　　6 用法举例

      　　BOOL _declspec(dllexport)_stdcall InstallHook()

      　　{

      　　hkb = SetWindowsHookEx(WH_KEYBOARD,

      　　(HOOKPROC)KeyboardProc,

      　　hins,

      　　0);

      　　return TRUE;

      　　}

#### 11. c++11添加的新特性

##### 1.右引用

1. ​	转移语义

   使用右值移动，右值可以赋值给左值或者绑定到引用。右值是一个临时对象。

   **对于左值，如果我们明确放弃对其资源的所有权，则可以通过std::move()来将其转为右值引用。std::move()实际上是static_cast()的简单封装。**

   右值引用应用场景

   - 按值传入参数。

     ```c++
     
     class People {
     public:
       People(string name) // 按值传入字符串，可接收左值、右值。接收左值时为复制，接收右值时为移动
       : name_(move(name)) // 显式移动构造，将传入的字符串移入成员变量
       {
       }
       string name_;
     };
      
     People a("Alice"); // 移动构造name
      
     string bn = "Bob";
     People b(bn); // 拷贝构造name
     ```

     如果你要在构造函数中接收`std::shared_ptr`并且存入类的成员（这是非常常见的），那么按值传入更是不二选择。拷贝`std::shared_ptr`需要线程同步，相比之下移动`std::shared_ptr`是非常轻松愉快的。
   
     ```c++
     class People{
         public:
         People(shared_ptr<int> a):id(move(a))
         {
             
         }
         shared_ptr<int> id;
     }
     
     shared_ptr<int> val = make_shared<int>();
     *val = 8;
     People Tom(val); // 移动构造id。
     ```


​     

   - 按值返回

     ```c++
     
     vector<string> str_split(const string& s) {
       vector<string> v;
       // ...
       return v; // v是左值，但优先移动，不支持移动时仍可复制。
     }
     ```

     unique_ptr
     
     **返回值必须是栈上，类的成员变量不行，临时变量可以**
     
     
     ```c++
     
     unique_ptr<SomeObj> create_obj(/*...*/) {
       unique_ptr<SomeObj> ptr(new SomeObj(/*...*/));
       ptr->foo(); // 一些可能的初始化
       return ptr;
     }
     //当然还有更简单的形式
     unique_ptr<SomeObj> create_obj(/*...*/) {
       return unique_ptr<SomeObj>(new SomeObj(/*...*/));
     }
     ```

   - 接收右值表达式

     ```c++
     void push_back( const T& value ); // (1)
     void push_back( T&& value ); // (2)
     
     vector<vector<string>> vv;
     vector<string> v = {"123", "456"};
      
     v.push_back("789"); // 临时构造的string类型右值被移动进容器v
     vv.push_back(move(v)); // 显式将v移动进vv
	```

   - std::vector的增长

     以前vector增长会重新申请内存，并一个个复制过去。

     现在只需要移动

   - std::unique_ptr放入容器

     过去由于vector增长会复制对象，而unique_ptr不能复制，所以不能放入vector。

     现在可以。

   - std::thread的传递

     thread也是一种不可复制的资源，但可以通过移动来传递所有权。

   当形参是右值只有实参是右值才会作为右值传入，否则推导为左值。

##### 2.cast 

	- 一般都是转指针或者引用。
	- static_cast  编译时检查

```c++
float a=1.0f;
int b=static_cast<int> a;
```

- const_cast 把const转为非const，或者非const转为const

- reinterpret_cast 只在必要时使用

- dynamic_cast 和上面三种不同，依靠RTTI（run time type identification） **运行时检查**

  可以使类型、指针、引用进行安全的转换 <a hrep=https://www.cnblogs.com/xiangtingshen/p/10851851.html>link</a>

  所谓安全的转换就是，这个基类实际是子类转来的，想要再转回去的时候就是安全的转换。

  e.g.

  ```c++
  class based 
  {
      public:
      based(){cout<<"base is construct"<<endl;};
      ~based(){cout<<"base is delete"<<endl;};
      
  }
  
  class derived :public based
  {
      public:
      derived(){cout<<"derived is construct"<< endl;};
      ~derived(){cout<<"derived is delete"<<endl;};
  }
  
  test()
  {
      based* base = new derived();
      derived* derive = dynamic_cast<derived*>(base);
      // 此处成功，因为可以安全的向下转换。
      based* base2 = new based();
      derived* derive2 = dynamic_cast<derived*>(base2);
      if(!derive2)
          cout<<"dynamic cast failed!"<<endl;
      // 此处会失败因为不安全从基类转换为子类。
      try
      {
          base a;
          based& baseref=a;
          derived& deriveref=dynamic_cast<derived&>(baseref);
          // 此处也会失败，理由同上，但是会抛出一个异常 badcast
      }
      catch(std::exception e)
      {
          cout<<e.what()<<endl;
      }
  }
  ```

  



#### 12. 智能指针

	##### 1. unique_ptr

 1.  unique_ptr .reset() 重置对象，并delete指针。

 2. unique_ptr.release() 释放关联对象，返回原始指针。没有delete。

 3. 转移unique_ptr

    ```c++
    // 通过原始指针创建 taskPtr2
    std::unique_ptr<Task> taskPtr2(new Task(55));
    // 把taskPtr2中关联指针的所有权转移给taskPtr4
    std::unique_ptr<Task> taskPtr4 = std::move(taskPtr2);
    // 现在taskPtr2关联的指针为空
    if(taskPtr2 == nullptr)
    	std::cout<<"taskPtr2 is  empty"<<std::endl;
    
    // taskPtr2关联指针的所有权现在转移到了taskPtr4中
    if(taskPtr4 != nullptr)
    	std::cout<<"taskPtr4 is not empty"<<std::endl;
    
    // 会输出55
    std::cout<< taskPtr4->mId << std::endl;
    ————————————————
    版权声明：本文为CSDN博主「码农小明」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
    原文链接：https://blog.csdn.net/shaosunrise/article/details/85158249
    ```

4. unique_ptr 不能调用复制构造和赋值函数

   ```c++
   std::unique_ptr<Task> taskPtr3 = taskPtr2; //调用复制构造函数，编译出错。
   taskPtr = taskPtr2; //调用赋值函数，编译出错。
   ```

5. 使用std::make_unique 创建 unique_ptr

   ```c++
   std::unique_ptr<Task> taskPtr = std::make_unique<Task>(34);
   ```

 6.  unique_ptr 作为参数，要使用引用

     ```c++
     // 移动ptr1，使用unique_ptr作为参数
     void moveptr(unique_ptr<int>& ptr1)
     {
         unique_ptr<int> inter_value;
         intervalue = std::move(ptr1);
     }
     
     int main()
     {
         // 定义ptr1
         unique_ptr<int> ptr1 = std::make_unique<int>(8);
         moveptr(ptr1);
     }
     ```

7. weak_ptr 

   可以避免shared_ptr相互引用导致的内存无法释放问题。

   weak_ptr 不能直接访问变量，需要先转化为shared_ptr

   ```c++
   shared_ptr<int> d = make_shared<int>(20);
   weak_ptr<int> a = d;
   shared_ptr<B> p=a.lock(); // lock返回一个shared_ptr，并锁定对象，避免被shared_ptr释放。 
   ```

   

#### 13.命令行编译

1. boost 例子

   ```bash
   cl /EHsc /I . D:\code\boostcode\temp.cpp ^
   /link /LIBPATH:D:Chorem下载\boost_1_76_0\bin.v2\libs
   ```

#### 14.io,iostream

​	<a href=https://blog.csdn.net/ayh2068/article/details/101457772>link</a>

#### 15.字符串编码

​	string是采用utf-8采用多字节，wstring采用unicode普遍是两字节存储。

​	多字节是可变的 ASCII码是一个字节，首位是0xxxxxxx

​	对于n个字节（n>1） ,第一个字节的前n位设为1，第n+1位设为0，后面的字节前两位都是10

​	


```c++
// utf-8的普遍格式
U+ 0000~ U+007F: 0xxxxxxx
U+ 0080~ U+07FF: 110XXXXX 10XXXXXX
U+ 0800~ U+FFFF: 1110xxxx 10xxxxxx 10xxxxxx
U+ 10000~U+10FFFF: 11110xxx 10xxxxxx 10xxxxxx
// unicode编码（UCS-2）
I 00000000 01001001
t 00000000 01110100
' 00000000 00100111
s 00000000 01110011
  00000000 00100000
知 01110111 11100101
乎 01001110 01001110
日 01100101 11100101
报 01100010 10100101
// utf-8编码
I 01001001
t 01110100
' 00100111
s 01110011
  00100000
知 11100111 10011111 10100101
乎 11100100 10111001 10001110
日 11100110 10010111 10100101
报 11100110 10001010 10100101
//GBK编码
知 D6AA 1101 0110 1010 1010
// 知 GBK编码一共两个字节，unicode编码三个字节
// 费流量和硬盘。
   
作者：uuspider
链接：https://www.zhihu.com/question/23374078/answer/65352538
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
#### 16.堆栈

<a href=https://blog.csdn.net/jirryzhang/article/details/79518408>link</a>

#### 17.减少IO的方式

1. 常规用法

```c++
//C++ code：
#include <iostream>
#include <fstream>
#include <string>
using namespace std;
class file{
public:
	//按行读数据,不分行写入另外一个文件
	bool fromShortToLong(string s_path,string d_path){
		string buffer;
		fstream infile(s_path);
		fstream outfile(d_path);
		if(!infile){
			cout << "Unable to open infile";
			exit(1); // terminate with error
		}
		if(!outfile){
			cout << "Unable to open outfile";
			exit(1); // terminate with error
		}do{
			outfile<<buffer;
		}while (getline(infile,buffer));
		cout<<"读写完成。"<<endl;
		system("pause");
		outfile.close();
		infile.close();
	}
};
void main(){
	file test;
	test.fromShortToLong("D://test_read.txt","D://test_write.txt");
}
```

2. 赋内存减少IO用法

   ```c++
   bool fromShortToLong(string s_path,string d_path)
   {
   	string buffer;
   	ifstream infile(s_path.c_str());
   	ofstream outfile(d_path.c_str());
   	if(!infile)
   	{
   		cout << "Unable to open infile";
   		exit(1); // terminate with error
   	}
   	if(!outfile)
   	{
   		cout << "Unable to open outfile";
   		exit(1); // terminate with error
   	}
   	buffer.assign(istreambuf_iterator<char>(infile),istreambuf_iterator<char>());
   	stringstream strStr;
   	strStr.str(buffer);
   	string linestr;
   	do
   	{
   		outfile<<linestr;
   	}
   	while (getline(strStr,linestr));
   	cout<<"读写完成。"<<endl;
   	return true;
   }
   ```

#### 17. 如何使用stackoverflow

​	<a href=https://blog.csdn.net/weixin_38233274/article/details/80349534>link</a>

***



## Fortran

#### 1.数组



1. 数组作为参数的三种方式

   ```fortran
   Program main
   	implicit none
   	real a(2,3)
   	
   	interface
   		Subroutine fun3(a)
   			real a(:,:)
   		end Subroutine fun3
   	end interface
   	
   	call fun1(a)
   	Write(*,'(6f3.0)')a
   	
   	call fun2(a,2,3)
   	Write(*,'(6f3.0)')a
   	
   	call fun3(a)
   	Write(*,'(6f3.0)')a
   End Program main
   ! c++调用的时候这种好使
   Subroutine fun1(a)
   real a(*)
   
   	a(1:6)=1
   end Subroutine
   
   Subroutine fun2(a,m,n)
   integer m,n
   real a(m,n)
   	
   	a=2
   end Subroutine
   
   Subroutine fun3(a)
   real a(:,:)
   
   	a=3
   end Subroutine
   ```

2. 未初始化的整数值是-858993460

#### 2.字符串

1. write(str,*) “-SLAB”  结果str以空格开头  " -SLAB"

   write(str,('A')) "-SLAB"  结果和输入一致 "-SLAB"

2. c++-fortran接口传递字符串

   - 字符串最好单独用reference修饰，避免传递字符串长度。

   - 字符串长度传递方式设置： Fortran:arrow_forward: External Procedure :arrow_forward: String Length Argument Passing:arrow_forward:对应的选项

   -  REFERENCE specifies a dummy argument's memory location is to be passed instead of the argument's value.

     VALUE specifies a dummy argument's value is to be passed instead of the argument's memory location.

     When VALUE is specified for a dummy argument, the actual argument passed to it can be of a different type. If necessary, type conversion is performed before the subprogram is called.

     When a complex (KIND=4 or KIND=8) argument is passed by value, *two* floating-point arguments (one containing the real part, the other containing the imaginary part) are passed by immediate value.

     Character values, substrings, assumed-size arrays, and adjustable arrays cannot be passed by value.

     If REFERENCE (only) is specified for a character argument, the string is passed with no length.

     If REFERENCE is specified for a character argument, and C (or STDCALL) has been specified for the routine, the string is passed with no length. This is true even if REFERENCE is also specified for the routine.

     If REFERENCE and C (or STDCALL) are specified for a routine, but REFERENCE has *not* been specified for the argument, the string is passed with the length.

     VALUE is the default if the C or STDCALL option is specified in the subprogram definition.

3.  fortran 它与 C 字符串最大的区别就是：Fortran字符串是固定长度的，没有 \0 结束符。

   ```fortran
   ! 字符串后面加C则按照c字符串末尾加'\0'
   dbname='dataA.db'C
   ```

   

#### 3.指针

 1. 指针分配的内存需要手动删除

    ```fortran
    program Console1
    
        implicit none
        type arrchip
            integer(kind=4):: arrcomop(4)
            type(arrchip),pointer:: arrnext
        endtype
        type arr
            integer(kind=4),allocatable::arrcomp(:)
            type(arrchip),pointer::head
        end type
        type(arr),allocatable::testarr
        type(arrchip),pointer::arrp,headsave,headnextsave
        integer(kind=4)::i
        ! Variables
        allocate(testarr)
        do i=1,10000000
            if(i==1) then
                allocate(testarr%head)    
                arrp=>testarr%head
            else
                allocate(arrp%arrnext)
                arrp=>arrp%arrnext
            endif
            arrp%arrcomop = 5
        end do
        headsave=>testarr%head
        headnextsave=>testarr%head%arrnext
        !deallocate(testarr%arrcomp)
        deallocate(testarr)
        if(associated(headsave)) then
            print *,'Head not delete'
            print *,headsave%arrcomop 
            !虽然删除了testarr,但是head指针指向的内存仍存在，需要手动释放
        else
            print *,'Head delete'
        endif
        if(associated(headnextsave)) then
            print *,'Next not delete'
            print *,headnextsave%arrcomop
        else
            print *,'Next delete'
        endif
        ! Body of Console1
    
        end program Console1
    ```


#### 4.作为dll的设置

- ​	不能用write(\*,\*) ，会破坏屏幕

#### 5.并行问题

##### 5.1并行分配数组

- 此时对需要分配的数组采用FIRSTPRIVATE属性，会使变量传入是否allocated的属性。

  ```fortran
  !$OMP PARALLEL DEFAULT(PRIVATE) FIRSTPRIVATE(XLOAD,FQ_OUT) IF(useOMPS)
  !$OMP DO 
  do iBeam = 1,nBeam
  	if(allocated(XLOAD)) deallocate(XLOAD)
      allocate(XLOAD(9,pBeamS%iEle_Load+1))
  end do
  !$OMP END DO NOWAIT
  !$OMP END PARALLEL
  ```

#### 6. 跨平台

##### 6.1 XP平台fortran程序无法运行

- linker:arrow_forward:syetem:arrow_forward:subsystem:arrow_forward:对应的XP选项

#### 7 . 并行

1. 默认变量属性是共享的

   ```fortran
   !$OMP PARALLEL DEFAULT(PRIVATE) SHARED(a)
   ! 此时除了变量a,其余均为私有属性。
   ```

2.   共有变量的赋值最好只有一个线程进行

3.  为确保前程安全和动态库正确加载，主程序也需要 openMP选项编译<a href = https://software.intel.com/content/www/us/en/develop/documentation/fortran-compiler-oneapi-dev-guide-and-reference/top/compiler-reference/compiler-options/compiler-option-details/offload-compilation-options-openmp-options-and-parallel-processing-options/qopenmp-qopenmp.html#qopenmp-qopenmp> link </a>



[^ 1 ]: 

## VS设置

#### 1.MFC

1. #### MSVCRT.lib 和 LIBCMT.lib冲突

   msvcrt.lib是VC中的Multithreaded DLL 版本的C运行时库，而libcmt.lib是Multithreaded的运行时库。在同一个项目中，所有的源文件必须链接相同的C运行时库。如果某一文 件用了Multithreaded DLL版本，而其他文件用了Single-Threaded或者Multithreaded版本的库，也就是说用了不同的库，就会导致这个警告的出现。
   ————————————————
   版权声明：本文为CSDN博主「xuesong9913」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
   原文链接：https://blog.csdn.net/yingmeng9913/article/details/49005535

2. \_WIN32,\_WIN64,WIN32

   **只要包含了 Windows.h，那么 WIN32 常量是肯定定义了的，所以不能用于判断平台环境**。

   _WIN32：Defined for applications for Win32 and Win64. **Always defined.**

　　_WIN64：Defined for applications for Win64.

​		在 Win32 配置下，_WIN32 有定义，_WIN64 没有定义。在 x64 配置下，两者都有定义。即**在 VC 下，_WIN32 一定有定义**。

　　因此，WIN32/_WIN32 可以用来判断是否 Windows 系统（对于跨平台程序），而 _WIN64 用来判断编译环境是 x86 还是 x64。最后附一个表：

| 常量\定义 | 预定义选项 | Windows.h      | VC编译器 |
| --------- | ---------- | -------------- | -------- |
| WIN32     | Win32      | √(minwindef.h) | ×        |
| _WIN32    | ×          | ×              | √        |
| _WIN64    | ×          | ×              | x64      |

  3. DLL 和 CRT

     VCRuntime code provides an internal DLL entry-point _DLLMainCRTStartup for message to attach and detach from a process or thread.

     _DLLMain is an optional function called by <i> _DLLMainCRTStartup</i> . Some libraries wrap the DllMain functoin for you. For example, in regular MFC DLL, the CWinApp object's InitInstance and ExitInstance member functions preform initialization and termination required by your DLL. for more details<a href = "https://docs.microsoft.com/en-us/cpp/build/run-time-library-behavior?view=vs-2019#initializing-regular-dlls"> MFC DLL</a>.

#### 2.编译时显示用到的lib

- /verbose:lib

#### 3.解决nafxcw.lb 和 LIBCMT.lib冲突的问题

- 调换连接顺序

#### 4.避免用户没有开发环境windows的版本、静态链接运行时库

- fortran ->library->/multithread
- c++ ->代码生成->/MT
- 静态链接运行时库会在每个dll创建相应的堆，因此必须遵守A申请内存，A清除内存的原则。
- 动态链接dll共用exe的堆，动态分配内存和清除内存不必在同一dll中进行。
- 编静态必须全部dll静态，否则还是依赖windows运行时库。

#### 5. VS脱机问题

- <a href = "https://docs.microsoft.com/zh-cn/previous-versions/aa289809(v=vs.71)?f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(VisualStudio.SourceControl.AddToScFileAlreadyControlled)%26rd%3Dtrue">link</a>

  1.在解决方案资源管理器中选择包含该项的项目。

  2.在“文件”菜单中，指向“源代码管理”，然后单击“更改源代码管理”。
  3.选择包含该项目的行，然后单击“绑定”。
  4.在“Choose project from SourceSafe”对话框中，选择要将项目绑定到的服务器文件夹，然后单击“OK”。







## Git命令

1. <img src=".\git命令45.webp" style="zoom:80%;" />

2. <img src=".\git命令.webp" style="zoom:80%;" />

3.  git cherry-pick(挑拣)<a href = "https://www.cnblogs.com/endless-code/p/11093861.html"> link</a>

   - 在dev分支执行git log命令，找到目标commit的commitid。

   - 切换到master分支

     ```c++
     git checkout master
     ```

   - 执行git cherry-pick命令

     ```c++
     git cherry-pick 32259aa35d0702d2d05c648938798f9a5bd4b9e7
     ```

   - 再次执行git log命令就可以看到目标提交到master上了。

   - 如果执行git cherry-pick合并之后发生了冲突，git会帮我们新建一个分支，如下所示

     ```c++
     纪鑫强@1403jixq MINGW64 /d/code/fem/FeMesh/FeMesh (jxq|CHERRY-PICKING)
     ```

     如果想取消注册合并，可以执行 git cherry-pick --quit或者git cherry-pick --abort命令取消这次挑拣。

     二者不同的地方在于前者将会将当前分支未冲突的内容状态变为modified，

     而后者则会直接将当前分支的内容退回到挑拣之前的状态。当然如果我们也可以解决冲突之后执行如下命令继续合并

     ```c++
     git add *
     git cherry-pick --continue
     ```

   - 这个解决冲突的方式有时会报错

     ```c++
     error: option `mainline' expects a number greater than zero
     ```

     此时可以使用vs2019完成挑拣

4. 删除跟踪

   ```c++
   git rm --cached .vs/FeMeshExe/v16/.suo
   ```

   

## 英文

#### 1.无法解析的外部符号

​	error LNK2001: unresolved external symbol

## RoadMap

### 1. licence

​	<img src=".\licence指示" style="zoom:80%;" />

## 数据库

### 1.example

<img src=".\数据库.png" style="zoom:80%;" />

2. 数据库加速
   - select union all
   - 索引

## GoogleTest

### 1. 配置

-  源码编译，静态库 gtest.lib，gtest_main.lib。有了gtest_main.lib 则测试里不需要再写main函数。

- 链接gtest.lib，gtest_main.lib，引用include目录，在预编译头添加

  ```c++
  #include "gtest\gtest.h"
  ```

- 编写测试代码。

  ```c++
  #include "stdafx.h"
  
  TEST(TestCaseName, TestName) {
  	EXPECT_EQ(1, 1);
  	EXPECT_TRUE(true);
  }
  ```


## 单元测试

###  1.单元测试和集成测试的区别

- ​	单元测试不需要访问网络，文件系统，数据库

- 如果我们认为我们正在编写一个单元测试来验证业务逻辑类中的一些微妙边缘情况，但却意识到它需要使用到Web服务或数据库等外部资源，那就意味着出问题了。实际上，我们正在使用大锤来 破解坚果（Essentially, we are using a sledgehammer to crack a nut.）。 这意味着糟糕的设计。

  作者：红色的Ricky
  链接：https://www.jianshu.com/p/b2c35b0ffb5e
  来源：简书

### 2. 单元测试：易写，可读，可靠，快速。不是集成测试

#### 2.1 可测试的代码

## CMAKE

### 1. cmake控制使用WindowsSDK版本

​	如果不设置，cmake会自己计算一个WindowsSDK版本，我看过的Win7系统一般是8.1

```cmake
#example
#在project前 set(CMAKE_SYSTEM_VERSION 10.0)
cmake_minimum_required (VERSION 3.10)
set(CMAKE_SYSTEM_VERSION 10.0)
project (Demo1)
add_executable(Demo main.cc)

```

2.cmake控制使用Visual Stdio 版本

- 先点击File->Delete Catche

<img src=".\cmake1.png" style="zoom:50%;" />

<img src=".\cmake2.png" style="zoom:50%;" />

## 调试

#### 1. GetPDB的断点加载不上

​	有时会是cpp文件结尾不是windows标准，选确定统一结尾符号就好了。

#### 2. debug没问题但是release有问题问题的原因

1. 初值
   - debug:  int -858993460
   - release: int 267443092

## 编译

 1. 无法找到... 文件夹

    应该是生成事件复制文件或者其他操作导致的

## Python

1. ``` python
   pyinstaller -F hello.py hello
   ```


### python 如果pip命令报错

- ​	使用python -m ensurepip <a h="https://blog.csdn.net/wangh0802/article/details/98895065">link</a>

### pyinstaller 不是内部或外部命令

- pip install pyinstaller

### 小工具

- listdll

​	