[TOC]

***



## 前端

#### 1.C-字符串

sprintf_s（src, "***"）

strcat(src1,src2) 组合

#### 2.CString

left(int n)

mid(int i,int n)

right(int n)

#### 3.全局变量

1. class类型的全局变量禁止
   - class全局变量的初始化顺序可能导致构造出现问题[^ 1 ]。
   - 内建类型和由内建类型构成的没有构造函数的结构体可以使用。
   - 如果一定要使用class全局变量请使用singleton pattern（单例模式）
2. 多线程代码非常数变量(含STL容器)也被禁止，不可以用函数返回值初始化全局变量。
3. 静态成员变量视作全局变量，也不可以是class类型。

​	

#### 4.类

1. 构造函数：构造函数不宜做逻辑复杂的初始化[^2]。

2. 初始化类不能用zeromemory，数组和结构体可以[^3]。

3. 明确的构造函数（Explicit Constructors）：对单参数构造函数使用C++关键字explicit，防止赋值时隐式转换。

4. 默认构造函数：当一个类定义若干成员变量又没有其他构造函数，需要定义一个默认构造函数，否则编译器自动产生默认构造函数。

5. 拷贝构造函数：仅需要拷贝一个类对象时使用拷贝构造函数；不需要时使用DISALLO_COPY_ASSIGN。

   ``` c++
   //禁止使用拷贝构造函数和赋值操作的宏
   //应在类的private：中使用
   #define DISALLOW_COPY_AND_ASSIGN(TypeNam)\
   TypeName(const TypeName&);\
   void operator=(const TypeName&)
   
   class Foo{
    public:
       Foo(int f);
       ~Foo();
    private:
       DISALLOW_COPY_AND_ASSIGN(Foo);
   }
   ```

6. 结构体和类：仅只有数据使用结构体，其他一概使用class。

7. 存取控制：变量foo_及取值函数foo()、赋值函数set_foo()。

8. 声明次序：public:\protected:\private:;如果那一块没有直接忽略即可。

   1. typedefs 和 enums；
   2. 常量
   3. 构造函数
   4. 析构函数
   5. 成员函数，含静态成员函数
   6. 数据成员，含静态数据成员
   7. 宏DISALLOW_COPY_AND_ASSIGN放在最后。
   8. .cpp和声明顺序一致。

9. STL容器中的对象，应该只使用std::tr1::shared_ptr。

10. 不具名的命名空间：在.cpp文件中提倡使用不具名命名空间，以避免命名冲突：

    ```c++
    namespace{
        //命名空间的内容无需缩进
        enum{UNUSED,EOF,ERROR}; //经常使用的符号
        bool AtEof(){return pos_==EOF;} //使用本命名空间内的符号EOF
    }//namespace
    
    //TODO:使用命名空间中的内容
    ```

11. 具名的命名空间：使用方式如下

    ```c++
    //.h文件
    namespace mynamespace{
        class MyClass{
            public:
            ...
            void Foo();
        };
    }// namespace mynamespace
    //.cc文件
    namespace mynamespace{
        void MyClass::Foo(){
            ...
        }
    }//namespace mynamespace
    ```

    通常.cpp中会包含更多、更复杂的细节，包括对其他命名空间中类的引用等。

    ```c++
    #include "a.h"
    
    DEFINE_bool(someflag,false,"dummy flag");
    
    class C;//全局命名空间中的类C的前置声明
    namespace a{class A;}//命名空间a中的类a::A的前置声明
    namespace b{
        ...code for b...
    }//namespace b
    ```

    不要声明命名空间std下的任何内容，包括标准库类的前置声明，声明std下的实体会导致不明确的行为，如，不可移植。声明标准库下的实体，需要包含对应的头文件。

    ```c++
    //允许：.cpp文件
    //.h文件中，必须在函数、方法或类的内部使用
    using::foo::bar;
    //允许：.cpp文件
    //.h文件中，必须在函数、方法或类的内部使用
    namespace fbz=::foo::bar::barZ;//别名
    ```

    

#### 5. 宏定义

1. 宏定义简化代码

   ```c++
   #define SWITCH(ar,i) if(ar[i] < ar[i+1]){\
   	int nTemp = ar[i];\
   	ar[i] = nNums[i+1];\
   	ar[i+1] = nTemp;}
   ```

2. 缺点:<b>无法单步调试、宏定义没有类型、命名空间对宏定义无效</b>

3. 编译时完全展开，如果有运算符号最好加上括号。

   ```c++
   #define WIDTH 80
   #define LENGTH WIDTH + 10
   
   int nArea = WIDTH * LENGTH;
   //等效于 int nArea = 80*80+10
   
   //正确用法
   #define WIDTH 80
   #define LENGTH (WIDTH+10)
   
   
   ```

   

#### 5.用法



1. 单例模式

   - 饿汉模式singleton

     适合多线程

   ```c++
   #include <iostream>
   
   using namespace std;
   
   class Singleton
   {
   	static Singleton intance;
   	Singleton()
   	{
   
   	}
   	Singleton(Singleton& that)
   	{
   
   	}
   	void operator = (Singleton& that)
   	{
   
   	}
   public:
   	static Singleton& getIntance(void)
   	{
   		return intance;
   	}
   };
   
   Singleton Singleton::intance;
   ```

   - 懒汉模式

      省内存，不适合多线程

   ```c++
   #include <iostream>
   
   using namespace std;
   
   class Singleton
   {
   	static Singleton* intance;
   	Singleton()
   	{
   
   	}
   	Singleton(Singleton& that)
   	{
   
   	}
   	void operator = (Singleton& that)
   	{
   
   	}
   public:
   	static Singleton& getIntance(void)
   	{
   		if(NULL == intance)
   		{
   			intance = new Singleton;
   		}
   		return *intance;
   	}
   	~ Singleton(void)
   	{
   		delete intance;
   	}
   };
   
   Singleton* Singleton::intance = NULL;
   ```

2. doxygen产生帮助文档

3. namespace fbz=::foo::bar::baz;

4. 禁止使用using指示符，以保证命名空间下所有名称可以正常使用。

   ```c++
   //禁止--污染命名空间
   using namespace foo;
   //允许：.cpp文件中
   //.h文件中，必须在函数方法或类的内部使用
   using ::foo::bar;
   ```

5. #define DEFINE_T_SUPER(B) private: typedef B T_Super; public:

6. 宏例子

   ```c++
   #define DETAILEDMODEL_EXTENSION(_name_)\
   class _name_##Extension : public PBBimCore::IPBObjectExtension\
   {\
   protected:\
       virtual PBBimCore::IPBObjectPtr        _GetPBObject() override\
                                                                                                   						        {\
       return _name_::Create();\
                                                                                                   						        } \
       virtual PBBimCore::IPBObjectPtr        _GetPBObject(BentleyApi::ECN::IECInstanceCR instance) override\
                                                                                                   						        {\
       return _name_::Create(instance);\
                                                                                                   						        }\
   };//IPBObjectExtension
   ```

7. 线程锁

   ```c++
   HANDLE mutex
   class ScopedMutex{
       public:
       ScopedMutex(HANDLE mutex){mutex.lock();}
       ~ScopedMutex(HANDLE mutex){mutex.unlock();}
   }
   ```

   

[^1]:<font size = 2 >因为，全局变量的构造函数、析构函数以及初始化操作的调用顺序只是部分规定，每次生成有可能有变化，从而导致难以发现的bug。</font>
[^2]: 如果对象需要有意义的初始化，考虑使用另外的Init()方法，并（或）增加一个成员标记用于指示对象是否已经初始化成功。
[^3]: 如果结构体中有虚函数或结构体成员中有虚函数，则会将虚函数指针置0，如果后续程序调用虚函数，空指针很可能导致程序崩溃。因此，有虚函数或成员函数中有虚函数的结构体初始化，一定要用构造函数来完成。另外，如果一个类的结构中包含STL模板，使用ZeroMemory对这个对象清零操作也会引起一系列的崩溃问题（指针指向内存错误、迭代器越界访问等）。

#### 6.字符串

1. unicode下各种字符串的转换

   ```c++
   1. Cstring std::string互转
   std::string strstring = "std::string";
   CString strCString = _T("CString");
   //CString->std::string
   strstring = CStringA(strCString);
   
   //std::string->CString
   strCString = strstring.c_str();
   
   2. int和CString
   //CString->int
   CString strInt = _T("123");
   int n=0;
   n = _ttoi(strInt);
   n = 9;
   //int->CString
   strInt.Format(_T(%d),n);
   
   3、double和CString
   CString strdouble = _T("123.00");
   double dVal = 0;
   //CString->double
   dVal = _tstof(strdouble);
   dVal = 999.0;
   //double->CString
   strdouble.Format(_T("%f"), dVal);
   
   4、char*和CString
   char* chchar = "chahdaslhdf";
   CString strCh = _T("char");
   //char*->CString
   strCh = chchar;
   //或者
   //预转换，得到所需空间的大小
   int wcsLen = ::MultiByteToWideChar(CP_ACP, NULL, chchar, strlen(chchar), NULL, 0);
   //分配空间要给'\0'留个空间，MultiByteToWideChar不会给'\0'空间
   wchar_t* wszString = new wchar_t[wcsLen + 1];
   //转换
   ::MultiByteToWideChar(CP_ACP, NULL, chchar, strlen(chchar), wszString, wcsLen);
   //最后加上'\0'
   wszString[wcsLen] = '\0';
   //附加到CString对象上
   CString content;
   content.Append(wszString);
   
   //CString->char*
   int n = strCh.GetLength(); //按字符计算，strCh的长度
   
   int len = WideCharToMultiByte(CP_ACP, 0, strCh, n, NULL, 0, NULL, NULL);//按Byte计算str长度
   char *pChStr = new char[len+1];//按字节为单位
   memset(pChStr,0,len+1);
   WideCharToMultiByte(CP_ACP, 0, strCh, n, pChStr, len, NULL, NULL);//宽字节转换为多字节编码
   pChStr[len] = '\0';
   memcpy(chDis, pChStr, len + 1);
   delete []pChStr;
   
   CString转char*
   //有问题，测试不通过，jxq
   char* ch = new char;
   CString str1 = _T("12121");
   strcpy(ch, CStringA(str1).GetString());
   
   5、将wchar_t*转化为char*
   
   char* UnicodeToAnsi(const wchar_t* szStr) 
   { 
       int nLen = WideCharToMultiByte( CP_ACP, 0, szStr, -1, NULL, 0, NULL, NULL ); 
       if (nLen == 0) 
       return NULL;
   
       char* pResult = new char[nLen+1]; 
       WideCharToMultiByte( CP_ACP, 0, szStr, -1, pResult, nLen, NULL, NULL );
       return pResult; 
   }
   
   6、将char*转化为wchar_t*
   
   wchar_t* AnsiToUnicode(const char* szStr) 
   { 
       int nLen = MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, szStr, -1, NULL, 0 ); 
       if (nLen == 0) 
       return NULL;
   
       wchar_t* pResult = new wchar_t[nLen+1]; 
       MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, szStr, -1, pResult, nLen ); 
       return pResult; 
   }
   
    
   
   7、头文件#include <sstream>
   //int->string
   int n1 = 0;
   std::stringstream ssCov;
   std::string str;
   ssCov<<n1;
   ssCov>>str;
   
   
   //string->int
   std::string strNum = "123";
   int n2 = atoi(strNum.c_str());
   
   //tchar 转 char
   std::string TCHAR2STRING（TCHAR *STR）
   
   {
   
    int iLen = WideCharToMultiByte(CP_ACP, 0,STR, -1, NULL, 0, NULL, NULL);
   
    char* chRtn =new char[iLen*sizeof(char)];
   
    WideCharToMultiByte(CP_ACP, 0, STR, -1, chRtn, iLen, NULL, NULL);
   
   std::string str(chRtn);
   
   return str;
   
   }
   ```
   
2. 多字节下各种字符串的转换

   ```c++
   //Cstring->char*
   char* buf;
   CString str="hello";
   buf=(LPSTR)(LPCTSTR)str;
   ```

 



#### 7.mfc

1. messagebox对话框在程序后面加MB_SYSTEMMODAL

   ```c++
   ::MessageBox(Null,info,)
       
   ```
   
2. COM的基础是这些概念。

   interface----对象通过它来展示其功能的机制。

   IUnknown----所有其他的基本接口都是基于它。它实现了通过COM运行的引用计数和接口查询机制。

   reference  counting----一个对象（或严格来说，一个接口）决定何时不再使用，因此可以自由地删除自己的技术。

   QueryInterface - 用于查询对象对给定接口的方法。

   Marshaling - 使对象可以跨线程、进程和网络边界使用的机制，允许位置独立。

   Aggregation - 一个对象可以利用另一个对象的一种方式。
   
3. 创建console并输出

   ```c++
   #include <fcntl.h>
   #include <io.h>
   
          
   
   void CallConcoleOutput(void)
   {
     int hCrt;
     FILE *hf;
     AllocConsole();
     hCrt=_open_osfhandle(
     (long)GetStdHandle(STD_OUTPUT_HANDLE),
     _O_TEXT );
     hf=_fdopen( hCrt, "w" );
     *stdout=*hf;
     setvbuf( stdout, NULL, _IONBF, 0 );
     // test code
     printf("InitConsoleWindow OK!/n");
   }
   ```

4. SendMessage 能以同步方式向目标窗体发送一条消息，然后等待目标窗体的处理过程处理。

   PostMessage 能以异步方式向目标窗体投递一条消息，消息投递出去函数立刻返回。

#### 8.调试经验

1. C/C++ 内存操作越界:sob:
    [<font size=1>转载链接</font>](<http://blog.sina.com.cn/s/blog_6b511ea50102visk.html>)

  - <font size=2>特点：莫名其妙出现众多问题，经常调来调去，不知原因所在，大部分都是内存操作引起的。现总结为两类：一类是无明显表现的，只会个程序带来莫名其妙的错误（1，2，3），一类调试时有明显表现（4，5）</font>

    1. <font size=2>字符串数组定义长度忘记+1（结束符）</font>

      ```c++
      char str[10];
      ::strcpy(str,"0123456789");
      ```

      <font size=2>此时会造成数组越界，因为strcpy将在str为起始地址的第11个单元写入‘0’，这样它将覆盖这个单元的值。</font>

      <font size=2>但是如果你仅仅作字符串操作，一个一个的存入，此时将不会越界，或者你使用strncpy(str,"0123456789",10)，它也不会越界。不过你得小心，此时将不能使用如：strlen，strcpy等等。它的长度和内容变得完全不确定，如果从str地址起的单元都不为‘’，那么将全看作为它的内容，此时对它的操作将会是多么的恐怖！</font>

    2. <font size=2>以指针操作数组</font>

       <font size=2>指针相对数组的下标操作来说，更灵活、更高效，但常常一不小心它就跑到不知地方的地方去了，在循环批量处理中，多移一位就产生了越界，如果是读还好，但如果是写，这就跟上面出现的问题一样了。</font>

    3. <font size=2>将对数据类型的错误操作</font>

       ```c++
       short int x;
       int y;
       x=y;
       //这种操作是不会出错，编译器会解释为x=(short int)y;丢弃y的高位。
       void *p;
       p=&x;
       *(int*)p=y;
       //这种操作会有问题。
       ```

       <font size=2>x只有两个字节的空间，而int需要4个字节的空间, 实际上己出问题了，但你放心，现在的编译器编译后不会引起错误，因为由于内存对齐操作，实际上它分配了4个字节给x，你没有写入到其它数中去，运行会完全正常。</font>

       <font color=orange size=2>但当你定义的是数组时，那就会有影响了，它会覆盖你后面的数据。
       或者你在不同的编程语言中进行数据交换时，而类型与类型宽度不一致就会出问题，如VB中的Integer只有2个字节，而VC中的int是4个，当接口定义不够好时，那就会引发程序崩溃。</font>

    4. <font size=2>使用new分配空间，但操作越界</font>:heart_decoration:

       <font size=2>这类越界要容易发现一点，只要你以debug版运行，只要你越界，程序肯定会在delete处停下来。第一次出现此类问题时，真是迷惑不解，我的指针怎么都没变，但就是delete不掉，老报错。由于不知越界会造成此类问题，我一直以为我的电脑哪出毛病了，很正确的事，它就是不对，简直气得我吐血，后来得人指点，才明白，原来这里面还有这个东东！同理malloc，free有此问题。</font>

    5. <font size=2>CString在GetBuffer后也容易出现越界</font>

       <font size=2>CString确实有很多好用的地方，我最爱它的地方就是作参数，它可以让被调用的函数内分配空间，而在函数外无需对得来的空间进行释放。在CString析构时，它就会帮你释放这块空间。</font>
       <font size=2>但在这里面有一个函数你使用不当就会出现越界问题，那就是CString::GetBuffer。通过操作它返回的指针，你便可以直接操作它的缓冲区，这相对通过它的方法来操作内容效率要高出很多，但若你一不小心越界了，那错误也就出来了。不过还好在调试版中，ReleaseBuffer时会报错，若你没有调用ReleaseBuffer，那将在CString析构时报错。</font>

    6. <font size=2>函数返回指针</font>

       <font size=2>这种要尤其小心，返回的指针指向的内存要释放，而且不要直接使用该指针操作，例如</font>

       ```c++
       char *buffer;
       if((buffer=getcwd(NULL,0))==NULL){
           perror("_getcwderror");
       }else{
           printf("%s\nLength:%d\n",buffer,strlen(buffer));
           free(buffer);//如果不free，后面的代码运行就会有问题。
       }
       ```

       <font size=2>上面4、5、6在调试会报错，因为在释放内存时，都调用delete，而delete实现如下</font>

       ``` c++
       void __cdecl operator delete(void* p)
       {
       #if !defined(_AFX_NO_DEBUG_CRT) && defined(_DEBUG)
       _free_dbg(p, _NORMAL_BLOCK);
       #else
       free(p);
       #endif
       }
       ```

       <font size=2>_free_dbg(p, _NORMAL_BLOCK);　将会作很多方面的检查，如果出错，便会报告出来。而free(p);则只是简间的对内存释放</font>

    7. <font size=2>总结</font>

       <font size=2>通过上面几点，相信大家知道如何去避免一些内存越界问题，同时也了解内存越界会引发各类问题，在我们遇到一些希奇古怪的问题时，不防关心一下你的内存操作。</font>
       
    8. 一个简单的创建被调试进程的案例
    
       ```c++
       //1. 创建被调试进程之后，被调试进程的进程线程的句柄与ID如何获取(PROCESS_INFORMATION)。
       
       //2. DEBUG_EVENT 的数据结构，u是对应的事件种类的数据结构。
       
       //3. 等待被调试进程的大体流程：使用 WaitForDebugEvent，等待被调试事件；使用ContinueDebugEvent，继续执行被调试事件。
       
       //4. 加载DLL时如果输出DLL名字：这里有个坑，必须连续两次从目标进程中读取，第一次读取地址，第二次通过该地址获取DllName，即文件名
           
       #include "pch.h"
       #include <iostream>
       #include <Windows.h>
       #include <string>
       
       using namespace std;
       
       int main()
       {
           CHAR DllName[MAX_PATH] = {'\0'}; // 存储DLL的缓冲区
           SIZE_T nNumberOfBytesRead = 0;    // 读取的字节数
           DWORD dwAddrImageName = 0;
           STARTUPINFO si = { sizeof(si) };
           PROCESS_INFORMATION pi;
           string path;
       
           LPCSTR x = "C:\\Users\\97905\\Desktop\\记事本.exe";
           if (CreateProcessA(
               x, // 进程名字  
               NULL, // 命令行为空
               NULL, // 进程安全描述符
               NULL, // 线程安全描述符
               FALSE, // 不可继承
               DEBUG_ONLY_THIS_PROCESS | DEBUG_PROCESS, // 调试模式启动
               NULL, // 使用父进程的环境块
               NULL, // 与父进程有相同的目录
               (LPSTARTUPINFOA)&si, // 必须初始化
               &pi // 被创建进程的句柄，线程等有关信息
           )) {
               cout << "创建被调试进程成功！" << endl;
           }
           else {
               cout << "创建被调试进程失败，退出" << endl;
               exit(0);
           }
       
           // 等待调试事件
           DEBUG_EVENT de; // 申请调试事件
           // 循环读取调试事件
           while (WaitForDebugEvent(&de, INFINITE) != 0) {
               if (pi.dwProcessId == de.dwProcessId) {
                   switch (de.dwDebugEventCode) {
                   case EXCEPTION_DEBUG_EVENT: // 异常事件
                       cout << "EXCEPTION_DEBUG_EVENT：" << endl;
                       //ContinueDebugEvent(de.dwProcessId, de.dwThreadId
                       break;
                   case CREATE_THREAD_DEBUG_EVENT: // 线程创建事件
                       cout << "CREATE_THREAD_DEBUG_EVENT" << endl;
                       break;
                   case CREATE_PROCESS_DEBUG_EVENT: // 进程创建事件
                       cout << "EXCEPTION_DEBUG_EVENT" << endl;
                       break;
                   case EXIT_THREAD_DEBUG_EVENT: // 线程退出事件
                       cout << "EXIT_THREAD_DEBUG_EVENT" << endl;
                       break;
                   case EXIT_PROCESS_DEBUG_EVENT: // 进程退出事件
                       cout << "EXIT_PROCESS_DEBUG_EVENT" << endl;
                       break;
                   case LOAD_DLL_DEBUG_EVENT: // DLL加载事件
                       ReadProcessMemory(pi.hProcess, de.u.LoadDll.lpImageName, &dwAddrImageName, sizeof(dwAddrImageName), &nNumberOfBytesRead);
                       ReadProcessMemory(pi.hProcess, (void*)dwAddrImageName, DllName, sizeof(DllName), &nNumberOfBytesRead);
                       if (de.u.LoadDll.fUnicode) {
                           wprintf(L"DLLNAME: %s\n", DllName);
                       }
                       else {
                           printf("DLLNAME: %s\n", DllName);
                       }
                       break;
                   case UNLOAD_DLL_DEBUG_EVENT: // 卸载DLL事件
                       cout << "UNLOAD_DLL_DEBUG_EVENT" << endl;
                       break;
                   case OUTPUT_DEBUG_STRING_EVENT: // 输出DEBUG字符串事件
                       cout << "OUTPUT_DEBUG_STRING_EVENT: " << de.u.DebugString.fUnicode << endl;
                       break;
                   }
                   ContinueDebugEvent(de.dwProcessId, de.dwThreadId, DBG_CONTINUE);
               }
           }
       }
          
       ```
    
       

#### 9.lambda表达式

1. 

   ```c++
    1      2     3       4       5      7
   [=] (int a) mutable throw() -> int （4）
    {
        6
    }
   1. =值传递； &引用传递 
       [&total,factor]
       [&,factor]
       [=,&total]
   2. () 形参表
   3.  mutable 可以使在按值传递时能够改变传入的值
   4.  throw（）表明不抛出异常。此时如果函数体throw异常，会有警报C4297
   5. 返回值
   6. 函数体
   7. 传入实参
   ```


#### 10.Fortran调用

1. extern'C' 按照c语言方式在函数名前加下划线 ‘_’

2. __stdcall会在函数名后面加上@字节数

   ```c++
   //_ShowOpenPDBDlg@4
   extern "C" __declspec(dllexport) void __stdcall ShowOpenPDBDlg(int &status)
   //其中extern“C” 提供下划线 	__stdcall提供@和字节数
   ```

3. 关于fortran接口

   ```fortran
   SUBROUTINE DATA_Prepare(status)
   !Dec$ Attributes STDCALL,DLLIMPORT,  Decorate, Alias : 'ShowOpenPDBDlg' :: DATA_Prepare
   integer(kind=4) :: status
   !Dec$ Attributes REFERENCE:: status
   END SUBROUTINE
   其中 STDCALL和Decorate会提供@4
   DLLIMPORT会在函数前加上_imp
   所以符号就是__imp__ShowOpenPDBDlg@4
   ```

4. 名字修饰约定随调用约定和编译种类(C或C++)的不同而变化。函数名修饰约定随编译种类和调用约定

   　　的不同而不同，下面分别说明。

      　　a、C编译时函数名修饰约定规则：

      　　__stdcall调用约定在输出函数名前加上一个下划线前缀，后面加上一个“@”符号和其参数的字节数，

      　　格式为_functionname@number。

      　　__cdecl调用约定仅在输出函数名前加上一个下划线前缀，格式为_functionname。

      　　__fastcall调用约定在输出函数名前加上一个“@”符号，后面也是一个“@”符号和其参数的字节数，

      　　格式为@functionname@number。

      　　它们均不改变输出函数名中的字符大小写，这和PASCAL调用约定不同，PASCAL约定输出的函数名无任何修饰且全部大写。

      　　b、C++编译时函数名修饰约定规则：

      　　__stdcall调用约定：

      　　1、以“?”标识函数名的开始，后跟函数名；

      　　2、函数名后面以“@@YG”标识参数表的开始，后跟参数表；

      　　3、参数表以代号表示：

      　　X--void ，

      　　D--char，

      　　E--unsigned char，

      　　F--short，

      　　H--int，

      　　I--unsigned int，

      　　J--long，

      　　K--unsigned long，

      　　M--float，

      　　N--double，

      　　_N--bool，

      　　....

      　　PA--表示指针，后面的代号表明指针类型，如果相同类型的指针连续出现，以“0”代替，一个“0”代

      　　表一次重复；

      　　4、参数表的第一项为该函数的返回值类型，其后依次为参数的数据类型,指针标识在其所指数据类型前

      　　；

      　　5、参数表后以“@Z”标识整个名字的结束，如果该函数无参数，则以“Z”标识结束。

      　　其格式为“?functionname@@YG*****@Z”或“?functionname@@YG*XZ”，例如

      　　int Test1（char *var1,unsigned long）-----“?Test1@@YGHPADK@Z”

      　　void Test2（） -----“?Test2@@YGXXZ”

      　　__cdecl调用约定：

      　　规则同上面的_stdcall调用约定，只是参数表的开始标识由上面的“@@YG”变为“@@YA”。

      　　__fastcall调用约定：

      　　规则同上面的_stdcall调用约定，只是参数表的开始标识由上面的“@@YG”变为“@@YI”。

      　　VC++对函数的省缺声明是"__cedcl",将只能被C/C++调用.

      　　6 用法举例

      　　BOOL _declspec(dllexport)_stdcall InstallHook()

      　　{

      　　hkb = SetWindowsHookEx(WH_KEYBOARD,

      　　(HOOKPROC)KeyboardProc,

      　　hins,

      　　0);

      　　return TRUE;

      　　}



***



## Fortran

#### 1.数组



1. 数组作为参数的三种方式

   ```fortran
   Program main
   	implicit none
   	real a(2,3)
   	
   	interface
   		Subroutine fun3(a)
   			real a(:,:)
   		end Subroutine fun3
   	end interface
   	
   	call fun1(a)
   	Write(*,'(6f3.0)')a
   	
   	call fun2(a,2,3)
   	Write(*,'(6f3.0)')a
   	
   	call fun3(a)
   	Write(*,'(6f3.0)')a
   End Program main
   
   Subroutine fun1(a)
   real a(*)
   
   	a(1:6)=1
   end Subroutine
   
   Subroutine fun2(a,m,n)
   integer m,n
   real a(m,n)
   	
   	a=2
   end Subroutine
   
   Subroutine fun3(a)
   real a(:,:)
   
   	a=3
   end Subroutine
   ```

2. 未初始化的整数值是-858993460

#### 2.字符串

1. write(str,*) “-SLAB”  结果str以空格开头  " -SLAB"

   write(str,('A')) "-SLAB"  结果和输入一致 "-SLAB"



[^ 1 ]: 

## VS设置

1. #### MSVCRT.lib 和 LIBCMT.lib冲突

   msvcrt.lib是VC中的Multithreaded DLL 版本的C运行时库，而libcmt.lib是Multithreaded的运行时库。在同一个项目中，所有的源文件必须链接相同的C运行时库。如果某一文 件用了Multithreaded DLL版本，而其他文件用了Single-Threaded或者Multithreaded版本的库，也就是说用了不同的库，就会导致这个警告的出现。
   ————————————————
   版权声明：本文为CSDN博主「xuesong9913」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
   原文链接：https://blog.csdn.net/yingmeng9913/article/details/49005535

2. \_WIN32,\_WIN64,WIN32

   **只要包含了 Windows.h，那么 WIN32 常量是肯定定义了的，所以不能用于判断平台环境**。

   _WIN32：Defined for applications for Win32 and Win64. **Always defined.**

　　_WIN64：Defined for applications for Win64.

​		在 Win32 配置下，_WIN32 有定义，_WIN64 没有定义。在 x64 配置下，两者都有定义。即**在 VC 下，_WIN32 一定有定义**。

　　因此，WIN32/_WIN32 可以用来判断是否 Windows 系统（对于跨平台程序），而 _WIN64 用来判断编译环境是 x86 还是 x64。最后附一个表：

| 常量\定义 | 预定义选项 | Windows.h      | VC编译器 |
| --------- | ---------- | -------------- | -------- |
| WIN32     | Win32      | √(minwindef.h) | ×        |
| _WIN32    | ×          | ×              | √        |
| _WIN64    | ×          | ×              | x64      |



## Git命令

1. <img src=".\git命令45.webp" style="zoom:80%;" />

2. <img src=".\git命令.webp" style="zoom:80%;" />